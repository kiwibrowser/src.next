// Copyright 2023 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "third_party/blink/renderer/core/paint/box_background_paint_context.h"

#include "third_party/blink/renderer/core/frame/local_frame_view.h"
#include "third_party/blink/renderer/core/layout/fragmentation_utils.h"
#include "third_party/blink/renderer/core/layout/layout_box.h"
#include "third_party/blink/renderer/core/layout/layout_box_model_object.h"
#include "third_party/blink/renderer/core/layout/layout_view.h"
#include "third_party/blink/renderer/core/layout/physical_box_fragment.h"
#include "third_party/blink/renderer/core/layout/table/layout_table_cell.h"
#include "third_party/blink/renderer/core/paint/paint_info.h"
#include "third_party/blink/renderer/core/paint/paint_layer.h"
#include "third_party/blink/renderer/core/paint/paint_layer_scrollable_area.h"
#include "third_party/blink/renderer/core/paint/rounded_border_geometry.h"
#include "third_party/blink/renderer/core/style/border_edge.h"
#include "third_party/blink/renderer/platform/graphics/paint/geometry_mapper.h"
#include "third_party/blink/renderer/platform/graphics/paint/paint_controller.h"

namespace blink {

namespace {

// Computes the stitched table-grid rect relative to the current fragment.
PhysicalRect ComputeStitchedTableGridRect(const PhysicalBoxFragment& fragment) {
  const auto writing_direction = fragment.Style().GetWritingDirection();
  LogicalRect table_grid_rect;
  LogicalRect fragment_local_grid_rect;
  LayoutUnit stitched_block_size;

  for (const PhysicalBoxFragment& walker :
       To<LayoutBox>(fragment.GetLayoutObject())->PhysicalFragments()) {
    LogicalRect local_grid_rect = walker.TableGridRect();
    local_grid_rect.offset.block_offset += stitched_block_size;
    if (table_grid_rect.IsEmpty()) {
      table_grid_rect = local_grid_rect;
    } else {
      table_grid_rect.Unite(local_grid_rect);
    }

    if (&walker == &fragment) {
      fragment_local_grid_rect = local_grid_rect;
    }

    stitched_block_size +=
        LogicalFragment(writing_direction, walker).BlockSize();
  }

  // Make the rect relative to the fragment we are currently painting.
  table_grid_rect.offset.block_offset -=
      fragment_local_grid_rect.offset.block_offset;

  WritingModeConverter converter(
      writing_direction, ToPhysicalSize(fragment_local_grid_rect.size,
                                        writing_direction.GetWritingMode()));
  return converter.ToPhysical(table_grid_rect);
}

}  // Anonymous namespace

BoxBackgroundPaintContext::BoxBackgroundPaintContext(
    const LayoutView& view,
    const PhysicalOffset& element_positioning_area_offset)
    : box_(&view), positioning_box_(&view.RootBox()) {
  has_background_fixed_to_viewport_ = view.IsBackgroundAttachmentFixedObject();
  painting_view_ = true;
  // The background of the box generated by the root element covers the
  // entire canvas and will be painted by the view object, but the we should
  // still use the root element box for positioning.
  positioning_size_override_ = view.RootBox().Size();
  // The background image should paint from the root element's coordinate space.
  element_positioning_area_offset_ = element_positioning_area_offset;
}

BoxBackgroundPaintContext::BoxBackgroundPaintContext(
    const LayoutBoxModelObject& obj)
    : BoxBackgroundPaintContext(&obj, &obj) {}

// TablesNG background painting.
BoxBackgroundPaintContext::BoxBackgroundPaintContext(
    const LayoutTableCell& cell,
    PhysicalOffset cell_offset,
    const LayoutBox& table_part,
    PhysicalSize table_part_size)
    : BoxBackgroundPaintContext(&cell, &table_part) {
  painting_table_cell_ = true;
  cell_using_container_background_ = true;
  element_positioning_area_offset_ = cell_offset;
  positioning_size_override_ = table_part_size;
}

BoxBackgroundPaintContext::BoxBackgroundPaintContext(
    const PhysicalBoxFragment& fragment)
    : BoxBackgroundPaintContext(
          To<LayoutBoxModelObject>(fragment.GetLayoutObject()),
          To<LayoutBoxModelObject>(fragment.GetLayoutObject())) {
  DCHECK(box_->IsBox());

  if (fragment.IsTable()) {
    auto stitched_background_rect = ComputeStitchedTableGridRect(fragment);
    positioning_size_override_ = stitched_background_rect.size;
    element_positioning_area_offset_ = -stitched_background_rect.offset;
    box_has_multiple_fragments_ = !fragment.IsOnlyForNode();
  } else if (!fragment.IsOnlyForNode()) {
    // The element is block-fragmented. We need to calculate the correct
    // background offset within an imaginary box where all the fragments have
    // been stitched together.
    element_positioning_area_offset_ =
        OffsetInStitchedFragments(fragment, &positioning_size_override_);
    box_has_multiple_fragments_ = true;
  }
}

BoxBackgroundPaintContext::BoxBackgroundPaintContext(
    const LayoutBoxModelObject* box,
    const LayoutBoxModelObject* positioning_box)
    : box_(box),
      positioning_box_(positioning_box),
      has_background_fixed_to_viewport_(
          HasBackgroundFixedToViewport(*positioning_box)) {
  // Specialized constructor should be used for LayoutView.
  DCHECK(!IsA<LayoutView>(box));
  DCHECK(box);
  DCHECK(positioning_box);
}

PhysicalBoxStrut BoxBackgroundPaintContext::BorderOutsets() const {
  return positioning_box_->BorderOutsets();
}

PhysicalBoxStrut BoxBackgroundPaintContext::PaddingOutsets() const {
  return positioning_box_->PaddingOutsets();
}

PhysicalBoxStrut BoxBackgroundPaintContext::VisualOverflowOutsets() const {
  PhysicalRect border_box;
  if (positioning_box_->IsBox()) {
    border_box = To<LayoutBox>(positioning_box_)->PhysicalBorderBoxRect();
  } else {
    border_box = To<LayoutInline>(positioning_box_)->PhysicalLinesBoundingBox();
  }
  PhysicalRect visual_overflow =
      positioning_box_->Layer()
          ->LocalBoundingBoxIncludingSelfPaintingDescendants();
  return PhysicalBoxStrut(visual_overflow.Y() - border_box.Y(),
                          border_box.Right() - visual_overflow.Right(),
                          border_box.Bottom() - visual_overflow.Bottom(),
                          visual_overflow.X() - border_box.X());
}

PhysicalBoxStrut BoxBackgroundPaintContext::InnerBorderOutsets(
    const PhysicalRect& dest_rect,
    const PhysicalRect& positioning_area) const {
  gfx::RectF inner_border_rect =
      RoundedBorderGeometry::PixelSnappedRoundedInnerBorder(
          positioning_box_->StyleRef(), positioning_area)
          .Rect();
  PhysicalBoxStrut outset;
  // TODO(rendering-core) The LayoutUnit(float) constructor always rounds
  // down. We should FromFloatFloor or FromFloatCeil to move toward the border.
  outset.left = LayoutUnit(inner_border_rect.x()) - dest_rect.X();
  outset.top = LayoutUnit(inner_border_rect.y()) - dest_rect.Y();
  outset.right = dest_rect.Right() - LayoutUnit(inner_border_rect.right());
  outset.bottom = dest_rect.Bottom() - LayoutUnit(inner_border_rect.bottom());
  return outset;
}

SnappedAndUnsnappedOutsets BoxBackgroundPaintContext::ObscuredBorderOutsets(
    const PhysicalRect& dest_rect,
    const PhysicalRect& positioning_area) const {
  const ComputedStyle& style = positioning_box_->StyleRef();
  gfx::RectF inner_border_rect =
      RoundedBorderGeometry::PixelSnappedRoundedInnerBorder(style,
                                                            positioning_area)
          .Rect();

  BorderEdge edges[4];
  style.GetBorderEdgeInfo(edges);
  const PhysicalBoxStrut box_outsets = BorderOutsets();
  SnappedAndUnsnappedOutsets adjust;
  if (edges[static_cast<unsigned>(BoxSide::kTop)].ObscuresBackground()) {
    adjust.snapped.top = LayoutUnit(inner_border_rect.y()) - dest_rect.Y();
    adjust.unsnapped.top = box_outsets.top;
  }
  if (edges[static_cast<unsigned>(BoxSide::kRight)].ObscuresBackground()) {
    adjust.snapped.right =
        dest_rect.Right() - LayoutUnit(inner_border_rect.right());
    adjust.unsnapped.right = box_outsets.right;
  }
  if (edges[static_cast<unsigned>(BoxSide::kBottom)].ObscuresBackground()) {
    adjust.snapped.bottom =
        dest_rect.Bottom() - LayoutUnit(inner_border_rect.bottom());
    adjust.unsnapped.bottom = box_outsets.bottom;
  }
  if (edges[static_cast<unsigned>(BoxSide::kLeft)].ObscuresBackground()) {
    adjust.snapped.left = LayoutUnit(inner_border_rect.x()) - dest_rect.X();
    adjust.unsnapped.left = box_outsets.left;
  }
  return adjust;
}

PhysicalRect BoxBackgroundPaintContext::ComputePositioningArea(
    const PaintInfo& paint_info,
    const FillLayer& fill_layer,
    const PhysicalRect& paint_rect) const {
  if (ShouldUseFixedAttachment(fill_layer)) {
    return FixedAttachmentPositioningArea(paint_info);
  }
  return NormalPositioningArea(paint_rect);
}

PhysicalRect BoxBackgroundPaintContext::NormalPositioningArea(
    const PhysicalRect& paint_rect) const {
  if (painting_view_ || cell_using_container_background_ ||
      box_has_multiple_fragments_) {
    return {PhysicalOffset(), positioning_size_override_};
  }
  return paint_rect;
}

bool BoxBackgroundPaintContext::DisallowBorderDerivedAdjustment() const {
  return painting_view_ || painting_table_cell_ ||
         box_has_multiple_fragments_ ||
         positioning_box_->StyleRef().BorderImage().GetImage() ||
         positioning_box_->StyleRef().BorderCollapse() ==
             EBorderCollapse::kCollapse;
}

bool BoxBackgroundPaintContext::CanCompositeBackgroundAttachmentFixed() const {
  return !painting_view_ && has_background_fixed_to_viewport_ &&
         positioning_box_->CanCompositeBackgroundAttachmentFixed();
}

bool BoxBackgroundPaintContext::ShouldUseFixedAttachment(
    const FillLayer& fill_layer) const {
  // Only backgrounds fixed to viewport should be treated as fixed attachment.
  // See comments in the private constructor.
  return has_background_fixed_to_viewport_ &&
         // Solid color background should use default attachment.
         fill_layer.GetImage() &&
         fill_layer.Attachment() == EFillAttachment::kFixed;
}

bool BoxBackgroundPaintContext::HasBackgroundFixedToViewport(
    const LayoutBoxModelObject& object) {
  if (!object.IsBackgroundAttachmentFixedObject()) {
    return false;
  }
  // https://www.w3.org/TR/css-transforms-1/#transform-rendering
  // Fixed backgrounds on the root element are affected by any transform
  // specified for that element. For all other elements that are effected
  // by a transform, a value of fixed for the background-attachment property
  // is treated as if it had a value of scroll.
  for (const PaintLayer* layer = object.EnclosingLayer();
       layer && !layer->IsRootLayer(); layer = layer->Parent()) {
    // Check LayoutObject::HasTransformRelatedProperty() first to exclude
    // non-applicable transforms and will-change: transform.
    LayoutObject& ancestor = layer->GetLayoutObject();
    if (ancestor.HasTransformRelatedProperty() &&
        (layer->Transform() ||
         ancestor.StyleRef().HasWillChangeHintForAnyTransformProperty())) {
      return false;
    }
  }
  return true;
}

PhysicalRect BoxBackgroundPaintContext::FixedAttachmentPositioningArea(
    const PaintInfo& paint_info) const {
  const ScrollableArea* layout_viewport =
      box_->GetFrameView()->LayoutViewport();
  DCHECK(layout_viewport);
  PhysicalSize size(layout_viewport->VisibleContentRect().size());
  if (CanCompositeBackgroundAttachmentFixed()) {
    // The caller should have adjusted paint chunk properties to be in the
    // viewport space.
    return PhysicalRect(PhysicalOffset(), size);
  }
  gfx::PointF viewport_origin_in_local_space =
      GeometryMapper::SourceToDestinationProjection(
          box_->View()->FirstFragment().LocalBorderBoxProperties().Transform(),
          paint_info.context.GetPaintController()
              .CurrentPaintChunkProperties()
              .Transform())
          .MapPoint(gfx::PointF());
  return PhysicalRect(
      PhysicalOffset::FromPointFRound(viewport_origin_in_local_space),
      PhysicalSize(layout_viewport->VisibleContentRect().size()));
}

const ComputedStyle& BoxBackgroundPaintContext::Style() const {
  return box_->StyleRef();
}

const ImageResourceObserver& BoxBackgroundPaintContext::ImageClient() const {
  return *(painting_view_ ? box_ : positioning_box_);
}

const ComputedStyle& BoxBackgroundPaintContext::ImageStyle(
    const ComputedStyle& fragment_style) const {
  if (painting_view_ || cell_using_container_background_) {
    return positioning_box_->StyleRef();
  }
  return fragment_style;
}

PhysicalOffset BoxBackgroundPaintContext::OffsetInBackground(
    const FillLayer& fill_layer) const {
  if (ShouldUseFixedAttachment(fill_layer)) {
    return PhysicalOffset();
  }
  return element_positioning_area_offset_;
}

}  // namespace blink
